BT:

JS always required

Laag 0:
- Support voor touch/mobile devices (input field)

Laag 2:
- Upload results to server
- Show score screen with competitors

Laag 3: 
- Live updating competitors / score screen

Laag 4:
- User account
- Cookies / Localstorage

JS Layer 1:
- Functional in IE 8
- Also works without JS, since it requires JS not supported in IE8
- All basic game features are available here:
	- Creating a game
	- Playing the game
	- Seeing scores postgame

JS Layer 2:
- Will enable when addEventListener, classList and querySelector are supported
- Enabled basic JS swapping of the text input fields, and automatic submission at the end of the list.
- From this point, the game will gather more detailed scoring data, using every input used
- TODO: Try this on touch
- TODO: Add JS coloring to texts (wrong right etc) - Combine with CSS stuff

JS Layer 3:
- Will enable when WebSockets are available
- Will update competitor scoreboard on postgame
- Will show other players while playing the game (TODO: Figure out how much stats we're pushing here)

JS Layer 4:
- Will enable when ServiceWorkers are available
- Cache exsisting games/dictionaries client side
- Store played games to push later to the server

CSS Layer 1:
- Functional in IE8
- Basic CSS

CSS Layer 2:
- Assumes JS layer 2
- TODO: Try to overlay input and text - Must list to extra JS prepared class




So...
For BT:
- Do accesibility test (on mac!)
	- colorblind
	- sun
	- contrast
	- font size
	- show tests
	- Keyboardfriendly	
- Take screenies on IE8 (mac remote desktop?)
- Create feature planner (voorhoede ding)
- Code snippets in Readme
- add affordance/feedback on elements
- Do live updating scores -> I promised this
- Mobile/Touch test
- Feedback on input
- Set live?
- Show players actions during game
- Do more stuff?

- UPDATE THE README!!

For PM: 
- Fix docs!
- AUDITS!
- Describe PWA functionality
- How does it score in lighthouse?
- Show offline state?

Bedenk aan de hand van de workshop van Jasper, hoe jij de Service Worker wil implementeren in jou app. Maak hiervoor een job story / user story aan. Zorg ervoor dat je in ieder geval een aantal statische assets cached en serveert met de Worker. Geef ook feedback aan de gebruiker over de online/offline state. 

Meet met behulp van de Timeline en/of Network tab van de DevTools vóór en ná je aanpassingen de render tijd van de pagina. Doe in de README.md verslag van je bevindingen.

Vermeld ook je job story / user story in de README.md

Zorg ervoor dat je README.md en/of AUDIT.md in orde zijn. Dat wil zeggen dat het duidelijk is hoe je app geïnstalleerd en gebuild moet worden, en dat je duidelijk de performance winst per optimalisatie weergeeft.

https://thejunkland.com/blog/how-to-write-good-readme.html 
http://tom.preston-werner.com/2010/08/23/readme-driven-development.html


INSTALL LIVE!!